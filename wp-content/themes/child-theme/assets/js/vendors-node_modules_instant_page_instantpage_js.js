/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkmarkup_template"] = globalThis["webpackChunkmarkup_template"] || []).push([["vendors-node_modules_instant_page_instantpage_js"],{

/***/ "./node_modules/instant.page/instantpage.js":
/*!**************************************************!*\
  !*** ./node_modules/instant.page/instantpage.js ***!
  \**************************************************/
/***/ (() => {

eval("/*! instant.page v5.2.0 - (C) 2019-2023 Alexandre Dieulot - https://instant.page/license */\n\nlet _chromiumMajorVersionInUserAgent = null,\n  _allowQueryString,\n  _allowExternalLinks,\n  _useWhitelist,\n  _delayOnHover = 65,\n  _lastTouchTimestamp,\n  _mouseoverTimer,\n  _preloadedList = new Set();\nconst DELAY_TO_NOT_BE_CONSIDERED_A_TOUCH_INITIATED_ACTION = 1111;\ninit();\nfunction init() {\n  const isSupported = document.createElement('link').relList.supports('prefetch');\n  // instant.page is meant to be loaded with <script type=module>\n  // (though sometimes webmasters load it as a regular script).\n  // So it’s normally executed (and must not cause JavaScript errors) in:\n  // - Chromium 61+\n  // - Gecko in Firefox 60+\n  // - WebKit in Safari 10.1+ (iOS 10.3+, macOS 10.10+)\n  //\n  // The check above used to check for IntersectionObserverEntry.isIntersecting\n  // but module scripts support implies this compatibility — except in Safari\n  // 10.1–12.0, but this prefetch check takes care of it.\n\n  if (!isSupported) {\n    return;\n  }\n  const handleVaryAcceptHeader = 'instantVaryAccept' in document.body.dataset || 'Shopify' in window;\n  // The `Vary: Accept` header when received in Chromium 79–109 makes prefetches\n  // unusable, as Chromium used to send a different `Accept` header.\n  // It’s applied on all Shopify sites by default, as Shopify is very popular\n  // and is the main source of this problem.\n  // `window.Shopify` only exists on “classic” Shopify sites. Those using\n  // Hydrogen (Remix SPA) aren’t concerned.\n\n  const chromiumUserAgentIndex = navigator.userAgent.indexOf('Chrome/');\n  if (chromiumUserAgentIndex > -1) {\n    _chromiumMajorVersionInUserAgent = parseInt(navigator.userAgent.substring(chromiumUserAgentIndex + 'Chrome/'.length));\n  }\n  // The user agent client hints API is a theoretically more reliable way to\n  // get Chromium’s version… but it’s not available in Samsung Internet 20.\n  // It also requires a secure context, which would make debugging harder,\n  // and is only available in recent Chromium versions.\n  // In practice, Chromium browsers never shy from announcing \"Chrome\" in\n  // their regular user agent string, as that maximizes their compatibility.\n\n  if (handleVaryAcceptHeader && _chromiumMajorVersionInUserAgent && _chromiumMajorVersionInUserAgent < 110) {\n    return;\n  }\n  const mousedownShortcut = ('instantMousedownShortcut' in document.body.dataset);\n  _allowQueryString = 'instantAllowQueryString' in document.body.dataset;\n  _allowExternalLinks = 'instantAllowExternalLinks' in document.body.dataset;\n  _useWhitelist = 'instantWhitelist' in document.body.dataset;\n  const eventListenersOptions = {\n    capture: true,\n    passive: true\n  };\n  let useMousedown = false;\n  let useMousedownOnly = false;\n  let useViewport = false;\n  if ('instantIntensity' in document.body.dataset) {\n    const intensity = document.body.dataset.instantIntensity;\n    if (intensity.startsWith('mousedown')) {\n      useMousedown = true;\n      if (intensity == 'mousedown-only') {\n        useMousedownOnly = true;\n      }\n    } else if (intensity.startsWith('viewport')) {\n      const isNavigatorConnectionSaveDataEnabled = navigator.connection && navigator.connection.saveData;\n      const isNavigatorConnectionLike2g = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes('2g');\n      if (!isNavigatorConnectionSaveDataEnabled && !isNavigatorConnectionLike2g) {\n        if (intensity == \"viewport\") {\n          if (document.documentElement.clientWidth * document.documentElement.clientHeight < 450000) {\n            useViewport = true;\n            // Smartphones are the most likely to have a slow connection, and\n            // their small screen size limits the number of links (and thus\n            // server load).\n            //\n            // Foldable phones (being expensive as of 2023), tablets and PCs\n            // generally have a decent connection, and a big screen displaying\n            // more links that would put more load on the server.\n            //\n            // iPhone 14 Pro Max (want): 430×932 = 400 760\n            // Samsung Galaxy S22 Ultra with display size set to 80% (want):\n            // 450×965 = 434 250\n            // Small tablet (don’t want): 600×960 = 576 000\n            // Those number are virtual screen size, the viewport (used for\n            // the check above) will be smaller with the browser’s interface.\n          }\n        } else if (intensity == \"viewport-all\") {\n          useViewport = true;\n        }\n      }\n    } else {\n      const milliseconds = parseInt(intensity);\n      if (!isNaN(milliseconds)) {\n        _delayOnHover = milliseconds;\n      }\n    }\n  }\n  if (!useMousedownOnly) {\n    document.addEventListener('touchstart', touchstartListener, eventListenersOptions);\n  }\n  if (!useMousedown) {\n    document.addEventListener('mouseover', mouseoverListener, eventListenersOptions);\n  } else if (!mousedownShortcut) {\n    document.addEventListener('mousedown', mousedownListener, eventListenersOptions);\n  }\n  if (mousedownShortcut) {\n    document.addEventListener('mousedown', mousedownShortcutListener, eventListenersOptions);\n  }\n  if (useViewport) {\n    let requestIdleCallbackOrFallback = window.requestIdleCallback;\n    // Safari has no support as of 16.3: https://webkit.org/b/164193\n    if (!requestIdleCallbackOrFallback) {\n      requestIdleCallbackOrFallback = callback => {\n        callback();\n        // A smarter fallback like setTimeout is not used because devices that\n        // may eventually be eligible to a Safari version supporting prefetch\n        // will be very powerful.\n        // The weakest devices that could be eligible are the 2017 iPad and\n        // the 2016 MacBook.\n      };\n    }\n\n    requestIdleCallbackOrFallback(function observeIntersection() {\n      const intersectionObserver = new IntersectionObserver(entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            const anchorElement = entry.target;\n            intersectionObserver.unobserve(anchorElement);\n            preload(anchorElement.href);\n          }\n        });\n      });\n      document.querySelectorAll('a').forEach(anchorElement => {\n        if (isPreloadable(anchorElement)) {\n          intersectionObserver.observe(anchorElement);\n        }\n      });\n    }, {\n      timeout: 1500\n    });\n  }\n}\nfunction touchstartListener(event) {\n  _lastTouchTimestamp = performance.now();\n  // Chrome on Android triggers mouseover before touchcancel, so\n  // `_lastTouchTimestamp` must be assigned on touchstart to be measured\n  // on mouseover.\n\n  const anchorElement = event.target.closest('a');\n  if (!isPreloadable(anchorElement)) {\n    return;\n  }\n  preload(anchorElement.href, 'high');\n}\nfunction mouseoverListener(event) {\n  if (performance.now() - _lastTouchTimestamp < DELAY_TO_NOT_BE_CONSIDERED_A_TOUCH_INITIATED_ACTION) {\n    return;\n  }\n  if (!('closest' in event.target)) {\n    return;\n    // Without this check sometimes an error “event.target.closest is not a function” is thrown, for unknown reasons\n    // That error denotes that `event.target` isn’t undefined. My best guess is that it’s the Document.\n    //\n    // Details could be gleaned from throwing such an error:\n    //throw new TypeError(`instant.page non-element event target: timeStamp=${~~event.timeStamp}, type=${event.type}, typeof=${typeof event.target}, nodeType=${event.target.nodeType}, nodeName=${event.target.nodeName}, viewport=${innerWidth}x${innerHeight}, coords=${event.clientX}x${event.clientY}, scroll=${scrollX}x${scrollY}`)\n  }\n\n  const anchorElement = event.target.closest('a');\n  if (!isPreloadable(anchorElement)) {\n    return;\n  }\n  anchorElement.addEventListener('mouseout', mouseoutListener, {\n    passive: true\n  });\n  _mouseoverTimer = setTimeout(() => {\n    preload(anchorElement.href, 'high');\n    _mouseoverTimer = undefined;\n  }, _delayOnHover);\n}\nfunction mousedownListener(event) {\n  const anchorElement = event.target.closest('a');\n  if (!isPreloadable(anchorElement)) {\n    return;\n  }\n  preload(anchorElement.href, 'high');\n}\nfunction mouseoutListener(event) {\n  if (event.relatedTarget && event.target.closest('a') == event.relatedTarget.closest('a')) {\n    return;\n  }\n  if (_mouseoverTimer) {\n    clearTimeout(_mouseoverTimer);\n    _mouseoverTimer = undefined;\n  }\n}\nfunction mousedownShortcutListener(event) {\n  if (performance.now() - _lastTouchTimestamp < DELAY_TO_NOT_BE_CONSIDERED_A_TOUCH_INITIATED_ACTION) {\n    return;\n  }\n  const anchorElement = event.target.closest('a');\n  if (event.which > 1 || event.metaKey || event.ctrlKey) {\n    return;\n  }\n  if (!anchorElement) {\n    return;\n  }\n  anchorElement.addEventListener('click', function (event) {\n    if (event.detail == 1337) {\n      return;\n    }\n    event.preventDefault();\n  }, {\n    capture: true,\n    passive: false,\n    once: true\n  });\n  const customEvent = new MouseEvent('click', {\n    view: window,\n    bubbles: true,\n    cancelable: false,\n    detail: 1337\n  });\n  anchorElement.dispatchEvent(customEvent);\n}\nfunction isPreloadable(anchorElement) {\n  if (!anchorElement || !anchorElement.href) {\n    return;\n  }\n  if (_useWhitelist && !('instant' in anchorElement.dataset)) {\n    return;\n  }\n  if (anchorElement.origin != location.origin) {\n    let allowed = _allowExternalLinks || 'instant' in anchorElement.dataset;\n    if (!allowed || !_chromiumMajorVersionInUserAgent) {\n      // Chromium-only: see comment on “restrictive prefetch”\n      return;\n    }\n  }\n  if (!['http:', 'https:'].includes(anchorElement.protocol)) {\n    return;\n  }\n  if (anchorElement.protocol == 'http:' && location.protocol == 'https:') {\n    return;\n  }\n  if (!_allowQueryString && anchorElement.search && !('instant' in anchorElement.dataset)) {\n    return;\n  }\n  if (anchorElement.hash && anchorElement.pathname + anchorElement.search == location.pathname + location.search) {\n    return;\n  }\n  if ('noInstant' in anchorElement.dataset) {\n    return;\n  }\n  return true;\n}\nfunction preload(url, fetchPriority = 'auto') {\n  if (_preloadedList.has(url)) {\n    return;\n  }\n  const linkElement = document.createElement('link');\n  linkElement.rel = 'prefetch';\n  linkElement.href = url;\n  linkElement.fetchPriority = fetchPriority;\n  // By default, a prefetch is loaded with a low priority.\n  // When there’s a fair chance that this prefetch is going to be used in the\n  // near term (= after a touch/mouse event), giving it a high priority helps\n  // make the page load faster in case there are other resources loading.\n  // Prioritizing it implicitly means deprioritizing every other resource\n  // that’s loading on the page. Due to HTML documents usually being much\n  // smaller than other resources (notably images and JavaScript), and\n  // prefetches happening once the initial page is sufficiently loaded,\n  // this theft of bandwidth should rarely be detrimental.\n\n  linkElement.as = 'document';\n  // as=document is Chromium-only and allows cross-origin prefetches to be\n  // usable for navigation. They call it “restrictive prefetch” and intend\n  // to remove it: https://crbug.com/1352371\n  //\n  // This document from the Chrome team dated 2022-08-10\n  // https://docs.google.com/document/d/1x232KJUIwIf-k08vpNfV85sVCRHkAxldfuIA5KOqi6M\n  // claims (I haven’t tested) that data- and battery-saver modes as well as\n  // the setting to disable preloading do not disable restrictive prefetch,\n  // unlike regular prefetch. That’s good for prefetching on a touch/mouse\n  // event, but might be bad when prefetching every link in the viewport.\n\n  document.head.appendChild(linkElement);\n  _preloadedList.add(url);\n}\n\n//# sourceURL=webpack://markup-template/./node_modules/instant.page/instantpage.js?");

/***/ })

}]);