/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkmarkup_template"] = globalThis["webpackChunkmarkup_template"] || []).push([["node_modules_instant_page_instantpage_js"],{

/***/ "./node_modules/instant.page/instantpage.js":
/*!**************************************************!*\
  !*** ./node_modules/instant.page/instantpage.js ***!
  \**************************************************/
/***/ (() => {

eval("/*! instant.page v5.1.1 - (C) 2019-2020 Alexandre Dieulot - https://instant.page/license */\n\nlet mouseoverTimer;\nlet lastTouchTimestamp;\nconst prefetches = new Set();\nconst prefetchElement = document.createElement('link');\nconst isSupported = prefetchElement.relList && prefetchElement.relList.supports && prefetchElement.relList.supports('prefetch') && window.IntersectionObserver && 'isIntersecting' in IntersectionObserverEntry.prototype;\nconst allowQueryString = ('instantAllowQueryString' in document.body.dataset);\nconst allowExternalLinks = ('instantAllowExternalLinks' in document.body.dataset);\nconst useWhitelist = ('instantWhitelist' in document.body.dataset);\nconst mousedownShortcut = ('instantMousedownShortcut' in document.body.dataset);\nconst DELAY_TO_NOT_BE_CONSIDERED_A_TOUCH_INITIATED_ACTION = 1111;\nlet delayOnHover = 65;\nlet useMousedown = false;\nlet useMousedownOnly = false;\nlet useViewport = false;\nif ('instantIntensity' in document.body.dataset) {\n  const intensity = document.body.dataset.instantIntensity;\n  if (intensity.substr(0, 'mousedown'.length) == 'mousedown') {\n    useMousedown = true;\n    if (intensity == 'mousedown-only') {\n      useMousedownOnly = true;\n    }\n  } else if (intensity.substr(0, 'viewport'.length) == 'viewport') {\n    if (!(navigator.connection && (navigator.connection.saveData || navigator.connection.effectiveType && navigator.connection.effectiveType.includes('2g')))) {\n      if (intensity == \"viewport\") {\n        /* Biggest iPhone resolution (which we want): 414 × 896 = 370944\n         * Small 7\" tablet resolution (which we don’t want): 600 × 1024 = 614400\n         * Note that the viewport (which we check here) is smaller than the resolution due to the UI’s chrome */\n        if (document.documentElement.clientWidth * document.documentElement.clientHeight < 450000) {\n          useViewport = true;\n        }\n      } else if (intensity == \"viewport-all\") {\n        useViewport = true;\n      }\n    }\n  } else {\n    const milliseconds = parseInt(intensity);\n    if (!isNaN(milliseconds)) {\n      delayOnHover = milliseconds;\n    }\n  }\n}\nif (isSupported) {\n  const eventListenersOptions = {\n    capture: true,\n    passive: true\n  };\n  if (!useMousedownOnly) {\n    document.addEventListener('touchstart', touchstartListener, eventListenersOptions);\n  }\n  if (!useMousedown) {\n    document.addEventListener('mouseover', mouseoverListener, eventListenersOptions);\n  } else if (!mousedownShortcut) {\n    document.addEventListener('mousedown', mousedownListener, eventListenersOptions);\n  }\n  if (mousedownShortcut) {\n    document.addEventListener('mousedown', mousedownShortcutListener, eventListenersOptions);\n  }\n  if (useViewport) {\n    let triggeringFunction;\n    if (window.requestIdleCallback) {\n      triggeringFunction = callback => {\n        requestIdleCallback(callback, {\n          timeout: 1500\n        });\n      };\n    } else {\n      triggeringFunction = callback => {\n        callback();\n      };\n    }\n    triggeringFunction(() => {\n      const intersectionObserver = new IntersectionObserver(entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            const linkElement = entry.target;\n            intersectionObserver.unobserve(linkElement);\n            preload(linkElement.href);\n          }\n        });\n      });\n      document.querySelectorAll('a').forEach(linkElement => {\n        if (isPreloadable(linkElement)) {\n          intersectionObserver.observe(linkElement);\n        }\n      });\n    });\n  }\n}\nfunction touchstartListener(event) {\n  /* Chrome on Android calls mouseover before touchcancel so `lastTouchTimestamp`\n   * must be assigned on touchstart to be measured on mouseover. */\n  lastTouchTimestamp = performance.now();\n  const linkElement = event.target.closest('a');\n  if (!isPreloadable(linkElement)) {\n    return;\n  }\n  preload(linkElement.href);\n}\nfunction mouseoverListener(event) {\n  if (performance.now() - lastTouchTimestamp < DELAY_TO_NOT_BE_CONSIDERED_A_TOUCH_INITIATED_ACTION) {\n    return;\n  }\n  if (!('closest' in event.target)) {\n    // Without this check sometimes an error “event.target.closest is not a function” is thrown, for unknown reasons\n    // That error denotes that `event.target` isn’t undefined. My best guess is that it’s the Document.\n\n    // Details could be gleaned from throwing such an error:\n    //throw new TypeError(`instant.page non-element event target: timeStamp=${~~event.timeStamp}, type=${event.type}, typeof=${typeof event.target}, nodeType=${event.target.nodeType}, nodeName=${event.target.nodeName}, viewport=${innerWidth}x${innerHeight}, coords=${event.clientX}x${event.clientY}, scroll=${scrollX}x${scrollY}`)\n\n    return;\n  }\n  const linkElement = event.target.closest('a');\n  if (!isPreloadable(linkElement)) {\n    return;\n  }\n  linkElement.addEventListener('mouseout', mouseoutListener, {\n    passive: true\n  });\n  mouseoverTimer = setTimeout(() => {\n    preload(linkElement.href);\n    mouseoverTimer = undefined;\n  }, delayOnHover);\n}\nfunction mousedownListener(event) {\n  const linkElement = event.target.closest('a');\n  if (!isPreloadable(linkElement)) {\n    return;\n  }\n  preload(linkElement.href);\n}\nfunction mouseoutListener(event) {\n  if (event.relatedTarget && event.target.closest('a') == event.relatedTarget.closest('a')) {\n    return;\n  }\n  if (mouseoverTimer) {\n    clearTimeout(mouseoverTimer);\n    mouseoverTimer = undefined;\n  }\n}\nfunction mousedownShortcutListener(event) {\n  if (performance.now() - lastTouchTimestamp < DELAY_TO_NOT_BE_CONSIDERED_A_TOUCH_INITIATED_ACTION) {\n    return;\n  }\n  const linkElement = event.target.closest('a');\n  if (event.which > 1 || event.metaKey || event.ctrlKey) {\n    return;\n  }\n  if (!linkElement) {\n    return;\n  }\n  linkElement.addEventListener('click', function (event) {\n    if (event.detail == 1337) {\n      return;\n    }\n    event.preventDefault();\n  }, {\n    capture: true,\n    passive: false,\n    once: true\n  });\n  const customEvent = new MouseEvent('click', {\n    view: window,\n    bubbles: true,\n    cancelable: false,\n    detail: 1337\n  });\n  linkElement.dispatchEvent(customEvent);\n}\nfunction isPreloadable(linkElement) {\n  if (!linkElement || !linkElement.href) {\n    return;\n  }\n  if (useWhitelist && !('instant' in linkElement.dataset)) {\n    return;\n  }\n  if (!allowExternalLinks && linkElement.origin != location.origin && !('instant' in linkElement.dataset)) {\n    return;\n  }\n  if (!['http:', 'https:'].includes(linkElement.protocol)) {\n    return;\n  }\n  if (linkElement.protocol == 'http:' && location.protocol == 'https:') {\n    return;\n  }\n  if (!allowQueryString && linkElement.search && !('instant' in linkElement.dataset)) {\n    return;\n  }\n  if (linkElement.hash && linkElement.pathname + linkElement.search == location.pathname + location.search) {\n    return;\n  }\n  if ('noInstant' in linkElement.dataset) {\n    return;\n  }\n  return true;\n}\nfunction preload(url) {\n  if (prefetches.has(url)) {\n    return;\n  }\n  const prefetcher = document.createElement('link');\n  prefetcher.rel = 'prefetch';\n  prefetcher.href = url;\n  document.head.appendChild(prefetcher);\n  prefetches.add(url);\n}\n\n//# sourceURL=webpack://markup-template/./node_modules/instant.page/instantpage.js?");

/***/ })

}]);